<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CppDB: cppdb::result Class Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CppDB
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacecppdb.html">cppdb</a>      </li>
      <li class="navelem"><a class="el" href="classcppdb_1_1result.html">result</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<div class="title">cppdb::result Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="cppdb::result" -->
<p>This object represents query result.  
 <a href="classcppdb_1_1result.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="frontend_8h_source.html">cppdb/frontend.h</a>&gt;</code></p>

<p><a href="classcppdb_1_1result-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a97464840ed6033e7f935107fa896e104">result</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#afdcc48634964cd53b60dc3c6f28dec49">~result</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a5381e523ffc2223a3db6388a2e047765">result</a> (<a class="el" href="classcppdb_1_1result.html">result</a> const &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classcppdb_1_1result.html">result</a> const &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a5acf6cc3f8d01a57b62ec5e86f352e44">operator=</a> (<a class="el" href="classcppdb_1_1result.html">result</a> const &amp;)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a12f1db9ad48bb09952bc613d537662a5">index</a> (std::string const &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aaebe910478536778eb51fdb0c42923b0">find_column</a> (std::string const &amp;<a class="el" href="classcppdb_1_1result.html#a3d988c696978f3fa74566481481c5729">name</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a3d988c696978f3fa74566481481c5729">name</a> (int col)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a3a14716996f9f077bc66c1ed0a79be71">is_null</a> (int col)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a24bba30fec185e1dea907caba9175196">is_null</a> (std::string const &amp;n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ae8491138d37571c54fd4be5c5a06ac82">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ae94927e1328d4f3b62276f596a3434ee">empty</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">fetch</a> (int col, short &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aae10ad71c8e23c149564520f41421853">fetch</a> (int col, unsigned short &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#abce5d2c039bf8758c63b9b1c56517508">fetch</a> (int col, int &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a4798661e2629854fcf2f32e5a4bbd40f">fetch</a> (int col, unsigned &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ab81de00f439e511d3fbe9b24e101dc67">fetch</a> (int col, long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ac9767807e05f0febeba1ec8cff1849bf">fetch</a> (int col, unsigned long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a6e6ae40de0fa6a1d12be7a84106e4ca4">fetch</a> (int col, long long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a4ed755104256c0b517363de9023c25b6">fetch</a> (int col, unsigned long long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a219504c76c0361b5c76caa04617228c7">fetch</a> (int col, float &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a9ac1b41ae65bce23d94320b5b3930987">fetch</a> (int col, double &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a17a25992e824282c8b309860f2fc5a02">fetch</a> (int col, long double &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#afdb97d6063a9b67f3b9e23883d6dae93">fetch</a> (int col, std::string &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ae00f574f795b0a5244d1fef6deac7543">fetch</a> (int col, std::tm &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a4d56baeee89664f0299a09fa445a827d">fetch</a> (int col, std::ostream &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a9dfbc45ff1a4c3c652da61321727fe91">fetch</a> (std::string const &amp;n, short &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a7a179d78658dedd6ad0fe6308fb719cd">fetch</a> (std::string const &amp;n, unsigned short &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a8fe1b1d5b55e074b71f380751813e249">fetch</a> (std::string const &amp;n, int &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ab6896bd7a9871a5d1cb1aa2f4ce1d961">fetch</a> (std::string const &amp;n, unsigned &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a264d47f100d937ff5f3ef92e3da64fc9">fetch</a> (std::string const &amp;n, long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a4581faa0ecd0e20f5b16d7c6ee051919">fetch</a> (std::string const &amp;n, unsigned long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a7dec639690df5c71bc521213546ecff5">fetch</a> (std::string const &amp;n, long long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a37536b5156445a3fdf24c79844bc9e2c">fetch</a> (std::string const &amp;n, unsigned long long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a1e8fff602e610fee3b72a5cf12fe93a8">fetch</a> (std::string const &amp;n, float &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ade6e07362cb421ea6372a4a90dc6607a">fetch</a> (std::string const &amp;n, double &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aeb8e461de773114d6c9c95301cf3a131">fetch</a> (std::string const &amp;n, long double &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a4d50bd0fc2266456b053b5ec05a9c047">fetch</a> (std::string const &amp;n, std::string &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a23689ec7c53b978e8e9852dd975e1dfb">fetch</a> (std::string const &amp;n, std::tm &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aaf7e2500b65b3a4fb94f9ce50b33d5ca">fetch</a> (std::string const &amp;n, std::ostream &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#afb693ef2d2dfee80d720b3a82f2a5c15">fetch</a> (short &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#af59b527c1e977d019df26c702488a085">fetch</a> (unsigned short &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a9f3123059a5a1a59e334113f4d9b5cce">fetch</a> (int &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ade6fa9f3b4bbef877585e10eed1c4dca">fetch</a> (unsigned &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aeb0a66829f75c0348ef4724bc14d0c6a">fetch</a> (long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aaf7b170b3868083bce9b4c96122873a4">fetch</a> (unsigned long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a2335bcf79c0363b9839af2cae7a47ef8">fetch</a> (long long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a1a7bc7793d7acc10238e878746386c53">fetch</a> (unsigned long long &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a820969b68a30ca4b4ed30eee6540088d">fetch</a> (float &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ae832fe42af4ee9d515b732793f7e15a1">fetch</a> (double &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ab46e1ff835badba35e768bbd0b451cb1">fetch</a> (long double &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ad03edc3c8db99278af107b724352bc3e">fetch</a> (std::string &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a25fa4e370b2eed773be8b7afcfc822d6">fetch</a> (std::tm &amp;v)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a35deeda2b05998fefae3df28bb5ab0da">fetch</a> (std::ostream &amp;v)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a2857f66096d699a11f9cdba51b02ad11">get</a> (std::string const &amp;<a class="el" href="classcppdb_1_1result.html#a3d988c696978f3fa74566481481c5729">name</a>)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ad50575b271c1402abb613676c4f1dfb5">get</a> (std::string const &amp;<a class="el" href="classcppdb_1_1result.html#a3d988c696978f3fa74566481481c5729">name</a>, T const &amp;def)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#aa6161bb5905c08438d740e11586cbfea">get</a> (int col)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#a91108e65c6db985593ad0096aafe466f">get</a> (int col, T const &amp;def)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppdb_1_1result.html">result</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#abd97afe7f35bc9cab506b5dbef2fcec5">operator&gt;&gt;</a> (tags::into_tag&lt; T &gt; ref)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classcppdb_1_1result.html">result</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classcppdb_1_1result.html#ac7cc80653e1fb917542a02aa47aa5e0a">operator&gt;&gt;</a> (T &amp;value)</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4682195a7dfc5da7346d8cfadcf0eb20"></a><!-- doxytag: member="cppdb::result::statement" ref="a4682195a7dfc5da7346d8cfadcf0eb20" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>statement</b></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This object represents query result. </p>
<p>This object and it is generally created by <a class="el" href="classcppdb_1_1statement.html#a8cfd4cb7580a33caea71f8a40c244c0f">statement::query()</a> call, default constructor is provided for consistency, but access to any member function with exception of <a class="el" href="classcppdb_1_1result.html#ae94927e1328d4f3b62276f596a3434ee">empty()</a> would throw an exception. </p>
</div><hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a97464840ed6033e7f935107fa896e104"></a><!-- doxytag: member="cppdb::result::result" ref="a97464840ed6033e7f935107fa896e104" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdb_1_1result.html#a97464840ed6033e7f935107fa896e104">cppdb::result::result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create an empty result, it is not useful except for having default constructor </p>

</div>
</div>
<a class="anchor" id="afdcc48634964cd53b60dc3c6f28dec49"></a><!-- doxytag: member="cppdb::result::~result" ref="afdcc48634964cd53b60dc3c6f28dec49" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdb_1_1result.html#afdcc48634964cd53b60dc3c6f28dec49">cppdb::result::~result</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Destroys the result, note, if the result of statement is not destroyed, it would not be returned to statements cache. </p>

</div>
</div>
<a class="anchor" id="a5381e523ffc2223a3db6388a2e047765"></a><!-- doxytag: member="cppdb::result::result" ref="a5381e523ffc2223a3db6388a2e047765" args="(result const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdb_1_1result.html#a97464840ed6033e7f935107fa896e104">cppdb::result::result</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdb_1_1result.html">result</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Copy result, note it only keeps the reference to actual object so copy is just copy of the reference </p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="ae8491138d37571c54fd4be5c5a06ac82"></a><!-- doxytag: member="cppdb::result::clear" ref="ae8491138d37571c54fd4be5c5a06ac82" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcppdb_1_1result.html#ae8491138d37571c54fd4be5c5a06ac82">cppdb::result::clear</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Clears the result, no further use of the result should be done until it is assigned again with a new statement result.</p>
<p>It is useful when you want to release all data and return the statement to cache </p>

</div>
</div>
<a class="anchor" id="a29559e91a01524ff72bfc1e697fd5b25"></a><!-- doxytag: member="cppdb::result::cols" ref="a29559e91a01524ff72bfc1e697fd5b25" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cppdb::result::cols</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return the number of columns in the result </p>

</div>
</div>
<a class="anchor" id="ae94927e1328d4f3b62276f596a3434ee"></a><!-- doxytag: member="cppdb::result::empty" ref="ae94927e1328d4f3b62276f596a3434ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#ae94927e1328d4f3b62276f596a3434ee">cppdb::result::empty</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Check if the current row is empty, it is in 3 cases:</p>
<ol type="1">
<li>Empty result</li>
<li><a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> wasn't called first time</li>
<li><a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> returned false; </li>
</ol>

</div>
</div>
<a class="anchor" id="a5666960dab2f5101b5bf06495a948bc4"></a><!-- doxytag: member="cppdb::result::fetch" ref="a5666960dab2f5101b5bf06495a948bc4" args="(int col, short &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>

</div>
</div>
<a class="anchor" id="aae10ad71c8e23c149564520f41421853"></a><!-- doxytag: member="cppdb::result::fetch" ref="aae10ad71c8e23c149564520f41421853" args="(int col, unsigned short &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="abce5d2c039bf8758c63b9b1c56517508"></a><!-- doxytag: member="cppdb::result::fetch" ref="abce5d2c039bf8758c63b9b1c56517508" args="(int col, int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a4798661e2629854fcf2f32e5a4bbd40f"></a><!-- doxytag: member="cppdb::result::fetch" ref="a4798661e2629854fcf2f32e5a4bbd40f" args="(int col, unsigned &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="ab81de00f439e511d3fbe9b24e101dc67"></a><!-- doxytag: member="cppdb::result::fetch" ref="ab81de00f439e511d3fbe9b24e101dc67" args="(int col, long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="ac9767807e05f0febeba1ec8cff1849bf"></a><!-- doxytag: member="cppdb::result::fetch" ref="ac9767807e05f0febeba1ec8cff1849bf" args="(int col, unsigned long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a6e6ae40de0fa6a1d12be7a84106e4ca4"></a><!-- doxytag: member="cppdb::result::fetch" ref="a6e6ae40de0fa6a1d12be7a84106e4ca4" args="(int col, long long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a4ed755104256c0b517363de9023c25b6"></a><!-- doxytag: member="cppdb::result::fetch" ref="a4ed755104256c0b517363de9023c25b6" args="(int col, unsigned long long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a219504c76c0361b5c76caa04617228c7"></a><!-- doxytag: member="cppdb::result::fetch" ref="a219504c76c0361b5c76caa04617228c7" args="(int col, float &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a9ac1b41ae65bce23d94320b5b3930987"></a><!-- doxytag: member="cppdb::result::fetch" ref="a9ac1b41ae65bce23d94320b5b3930987" args="(int col, double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a17a25992e824282c8b309860f2fc5a02"></a><!-- doxytag: member="cppdb::result::fetch" ref="a17a25992e824282c8b309860f2fc5a02" args="(int col, long double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="afdb97d6063a9b67f3b9e23883d6dae93"></a><!-- doxytag: member="cppdb::result::fetch" ref="afdb97d6063a9b67f3b9e23883d6dae93" args="(int col, std::string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a textual value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same, if possible it converts it into textual representation. </p>

</div>
</div>
<a class="anchor" id="ae00f574f795b0a5244d1fef6deac7543"></a><!-- doxytag: member="cppdb::result::fetch" ref="ae00f574f795b0a5244d1fef6deac7543" args="(int col, std::tm &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tm &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column <em>col</em> (starting from 0) into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast(). </p>
 
</div>
</div>
<a class="anchor" id="a4d56baeee89664f0299a09fa445a827d"></a><!-- doxytag: member="cppdb::result::fetch" ref="a4d56baeee89664f0299a09fa445a827d" args="(int col, std::ostream &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a binary large object value from column <em>col</em> (starting from 0) into a stream <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not blob, it may throw bad_value_cast() </p>

</div>
</div>
<a class="anchor" id="a9dfbc45ff1a4c3c652da61321727fe91"></a><!-- doxytag: member="cppdb::result::fetch" ref="a9dfbc45ff1a4c3c652da61321727fe91" args="(std::string const &amp;n, short &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>

</div>
</div>
<a class="anchor" id="a7a179d78658dedd6ad0fe6308fb719cd"></a><!-- doxytag: member="cppdb::result::fetch" ref="a7a179d78658dedd6ad0fe6308fb719cd" args="(std::string const &amp;n, unsigned short &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a8fe1b1d5b55e074b71f380751813e249"></a><!-- doxytag: member="cppdb::result::fetch" ref="a8fe1b1d5b55e074b71f380751813e249" args="(std::string const &amp;n, int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="ab6896bd7a9871a5d1cb1aa2f4ce1d961"></a><!-- doxytag: member="cppdb::result::fetch" ref="ab6896bd7a9871a5d1cb1aa2f4ce1d961" args="(std::string const &amp;n, unsigned &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a264d47f100d937ff5f3ef92e3da64fc9"></a><!-- doxytag: member="cppdb::result::fetch" ref="a264d47f100d937ff5f3ef92e3da64fc9" args="(std::string const &amp;n, long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a4581faa0ecd0e20f5b16d7c6ee051919"></a><!-- doxytag: member="cppdb::result::fetch" ref="a4581faa0ecd0e20f5b16d7c6ee051919" args="(std::string const &amp;n, unsigned long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a7dec639690df5c71bc521213546ecff5"></a><!-- doxytag: member="cppdb::result::fetch" ref="a7dec639690df5c71bc521213546ecff5" args="(std::string const &amp;n, long long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a37536b5156445a3fdf24c79844bc9e2c"></a><!-- doxytag: member="cppdb::result::fetch" ref="a37536b5156445a3fdf24c79844bc9e2c" args="(std::string const &amp;n, unsigned long long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a1e8fff602e610fee3b72a5cf12fe93a8"></a><!-- doxytag: member="cppdb::result::fetch" ref="a1e8fff602e610fee3b72a5cf12fe93a8" args="(std::string const &amp;n, float &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="ade6e07362cb421ea6372a4a90dc6607a"></a><!-- doxytag: member="cppdb::result::fetch" ref="ade6e07362cb421ea6372a4a90dc6607a" args="(std::string const &amp;n, double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="aeb8e461de773114d6c9c95301cf3a131"></a><!-- doxytag: member="cppdb::result::fetch" ref="aeb8e461de773114d6c9c95301cf3a131" args="(std::string const &amp;n, long double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="a4d50bd0fc2266456b053b5ec05a9c047"></a><!-- doxytag: member="cppdb::result::fetch" ref="a4d50bd0fc2266456b053b5ec05a9c047" args="(std::string const &amp;n, std::string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a textual value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same, if possible it converts it into textual representation. If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>

</div>
</div>
<a class="anchor" id="a23689ec7c53b978e8e9852dd975e1dfb"></a><!-- doxytag: member="cppdb::result::fetch" ref="a23689ec7c53b978e8e9852dd975e1dfb" args="(std::string const &amp;n, std::tm &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::tm &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from column named <em>n</em> into <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>
 
</div>
</div>
<a class="anchor" id="aaf7e2500b65b3a4fb94f9ce50b33d5ca"></a><!-- doxytag: member="cppdb::result::fetch" ref="aaf7e2500b65b3a4fb94f9ce50b33d5ca" args="(std::string const &amp;n, std::ostream &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a binary large object value from column named <em>name</em> into a stream <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not blob, it may throw bad_value_cast(). If the <em>n</em> value is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception </p>

</div>
</div>
<a class="anchor" id="afb693ef2d2dfee80d720b3a82f2a5c15"></a><!-- doxytag: member="cppdb::result::fetch" ref="afb693ef2d2dfee80d720b3a82f2a5c15" args="(short &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">short &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>

</div>
</div>
<a class="anchor" id="af59b527c1e977d019df26c702488a085"></a><!-- doxytag: member="cppdb::result::fetch" ref="af59b527c1e977d019df26c702488a085" args="(unsigned short &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned short &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="a9f3123059a5a1a59e334113f4d9b5cce"></a><!-- doxytag: member="cppdb::result::fetch" ref="a9f3123059a5a1a59e334113f4d9b5cce" args="(int &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="ade6fa9f3b4bbef877585e10eed1c4dca"></a><!-- doxytag: member="cppdb::result::fetch" ref="ade6fa9f3b4bbef877585e10eed1c4dca" args="(unsigned &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="aeb0a66829f75c0348ef4724bc14d0c6a"></a><!-- doxytag: member="cppdb::result::fetch" ref="aeb0a66829f75c0348ef4724bc14d0c6a" args="(long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="aaf7b170b3868083bce9b4c96122873a4"></a><!-- doxytag: member="cppdb::result::fetch" ref="aaf7b170b3868083bce9b4c96122873a4" args="(unsigned long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="a2335bcf79c0363b9839af2cae7a47ef8"></a><!-- doxytag: member="cppdb::result::fetch" ref="a2335bcf79c0363b9839af2cae7a47ef8" args="(long long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="a1a7bc7793d7acc10238e878746386c53"></a><!-- doxytag: member="cppdb::result::fetch" ref="a1a7bc7793d7acc10238e878746386c53" args="(unsigned long long &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="a820969b68a30ca4b4ed30eee6540088d"></a><!-- doxytag: member="cppdb::result::fetch" ref="a820969b68a30ca4b4ed30eee6540088d" args="(float &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">float &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="ae832fe42af4ee9d515b732793f7e15a1"></a><!-- doxytag: member="cppdb::result::fetch" ref="ae832fe42af4ee9d515b732793f7e15a1" args="(double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="ab46e1ff835badba35e768bbd0b451cb1"></a><!-- doxytag: member="cppdb::result::fetch" ref="ab46e1ff835badba35e768bbd0b451cb1" args="(long double &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">long double &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="ad03edc3c8db99278af107b724352bc3e"></a><!-- doxytag: member="cppdb::result::fetch" ref="ad03edc3c8db99278af107b724352bc3e" args="(std::string &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a textual value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same, if possible it converts it into textual representation.</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>

</div>
</div>
<a class="anchor" id="a25fa4e370b2eed773be8b7afcfc822d6"></a><!-- doxytag: member="cppdb::result::fetch" ref="a25fa4e370b2eed773be8b7afcfc822d6" args="(std::tm &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::tm &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a value from the next column in the row starting from the first one. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not same it tries to cast the data, if casting fails or the data is out of the type range, throws bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>
 
</div>
</div>
<a class="anchor" id="a35deeda2b05998fefae3df28bb5ab0da"></a><!-- doxytag: member="cppdb::result::fetch" ref="a35deeda2b05998fefae3df28bb5ab0da" args="(std::ostream &amp;v)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">cppdb::result::fetch</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Fetch a blob value from the next column in the row starting from the first one into stream <em>v</em>. Returns false if the value in NULL and <em>v</em> is not updated, otherwise returns true.</p>
<p>If the data type is not blob, it may throw bad_value_cast().</p>
<p>If fetch was called more times then <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> it throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> exception, to use it once again from the beginning on the same row call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> member function. It is not required to call <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">rewind_column()</a> after calling <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> as column index is reset automatically. </p>

</div>
</div>
<a class="anchor" id="aaebe910478536778eb51fdb0c42923b0"></a><!-- doxytag: member="cppdb::result::find_column" ref="aaebe910478536778eb51fdb0c42923b0" args="(std::string const &amp;name)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcppdb_1_1result.html#aaebe910478536778eb51fdb0c42923b0">cppdb::result::find_column</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert column name <em>n</em> to its index, returns -1 if the name is not valid. </p>

</div>
</div>
<a class="anchor" id="a2857f66096d699a11f9cdba51b02ad11"></a><!-- doxytag: member="cppdb::result::get" ref="a2857f66096d699a11f9cdba51b02ad11" args="(std::string const &amp;name)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classcppdb_1_1result.html#a2857f66096d699a11f9cdba51b02ad11">cppdb::result::get</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a value of type <em>T</em> from column named <em>name</em>. If the column is null throws null_value_fetch(), if the column <em>name</em> is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a>, if the column value cannot be converted to type T (see fetch functions) it throws <a class="el" href="classcppdb_1_1bad__value__cast.html" title="invalid data conversions">bad_value_cast</a>. </p>

</div>
</div>
<a class="anchor" id="ad50575b271c1402abb613676c4f1dfb5"></a><!-- doxytag: member="cppdb::result::get" ref="ad50575b271c1402abb613676c4f1dfb5" args="(std::string const &amp;name, T const &amp;def)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classcppdb_1_1result.html#a2857f66096d699a11f9cdba51b02ad11">cppdb::result::get</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a value of type <em>T</em> from column named <em>name</em>. If the column is null returns <em>def</em>, if the column <em>name</em> is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a>, if the column value cannot be converted to type T (see fetch functions) it throws <a class="el" href="classcppdb_1_1bad__value__cast.html" title="invalid data conversions">bad_value_cast</a>. </p>

</div>
</div>
<a class="anchor" id="aa6161bb5905c08438d740e11586cbfea"></a><!-- doxytag: member="cppdb::result::get" ref="aa6161bb5905c08438d740e11586cbfea" args="(int col)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classcppdb_1_1result.html#a2857f66096d699a11f9cdba51b02ad11">cppdb::result::get</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a value of type <em>T</em> from column <em>col</em> (starting from 0). If the column is null throws null_value_fetch(), if the column index is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a>, if the column value cannot be converted to type T (see fetch functions) it throws <a class="el" href="classcppdb_1_1bad__value__cast.html" title="invalid data conversions">bad_value_cast</a>. </p>

</div>
</div>
<a class="anchor" id="a91108e65c6db985593ad0096aafe466f"></a><!-- doxytag: member="cppdb::result::get" ref="a91108e65c6db985593ad0096aafe466f" args="(int col, T const &amp;def)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classcppdb_1_1result.html#a2857f66096d699a11f9cdba51b02ad11">cppdb::result::get</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T const &amp;&#160;</td>
          <td class="paramname"><em>def</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Get a value of type <em>T</em> from column <em>col</em> (starting from 0). If the column is null returns <em>def</em>, if the column index is invalid throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a>, if the column value cannot be converted to type T (see fetch functions) it throws <a class="el" href="classcppdb_1_1bad__value__cast.html" title="invalid data conversions">bad_value_cast</a>. </p>

</div>
</div>
<a class="anchor" id="a12f1db9ad48bb09952bc613d537662a5"></a><!-- doxytag: member="cppdb::result::index" ref="a12f1db9ad48bb09952bc613d537662a5" args="(std::string const &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classcppdb_1_1result.html#a12f1db9ad48bb09952bc613d537662a5">cppdb::result::index</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert column name <em>n</em> to its index, throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> if the name is not valid. </p>

</div>
</div>
<a class="anchor" id="a3a14716996f9f077bc66c1ed0a79be71"></a><!-- doxytag: member="cppdb::result::is_null" ref="a3a14716996f9f077bc66c1ed0a79be71" args="(int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a3a14716996f9f077bc66c1ed0a79be71">cppdb::result::is_null</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the column number <em>col</em> (starting from 0) has NULL value </p>

</div>
</div>
<a class="anchor" id="a24bba30fec185e1dea907caba9175196"></a><!-- doxytag: member="cppdb::result::is_null" ref="a24bba30fec185e1dea907caba9175196" args="(std::string const &amp;n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a3a14716996f9f077bc66c1ed0a79be71">cppdb::result::is_null</a> </td>
          <td>(</td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Return true if the column named <em>n</em> has NULL value </p>

</div>
</div>
<a class="anchor" id="a3d988c696978f3fa74566481481c5729"></a><!-- doxytag: member="cppdb::result::name" ref="a3d988c696978f3fa74566481481c5729" args="(int col)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classcppdb_1_1result.html#a3d988c696978f3fa74566481481c5729">cppdb::result::name</a> </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Convert column index to column name, throws <a class="el" href="classcppdb_1_1invalid__column.html" title="trying to fetch a value using invalid column index">invalid_column</a> if col is not in range 0&lt;= col &lt; <a class="el" href="classcppdb_1_1result.html#a29559e91a01524ff72bfc1e697fd5b25">cols()</a> </p>

</div>
</div>
<a class="anchor" id="a6d3a8f7e8ddf714775fb0e30b4db4fe7"></a><!-- doxytag: member="cppdb::result::next" ref="a6d3a8f7e8ddf714775fb0e30b4db4fe7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">cppdb::result::next</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Move forward to next row, returns false if no more rows available.</p>
<p>Notes:</p>
<ul>
<li>You should call <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> at least once before you use <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">fetch()</a> functions</li>
<li>You must not call <a class="el" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">fetch()</a> functions if <a class="el" href="classcppdb_1_1result.html#a6d3a8f7e8ddf714775fb0e30b4db4fe7">next()</a> returned false, it would cause <a class="el" href="classcppdb_1_1empty__row__access.html" title="attempt to fetch a value from the row without calling next() first time or when next() returned false...">empty_row_access</a> exception. </li>
</ul>

</div>
</div>
<a class="anchor" id="a5acf6cc3f8d01a57b62ec5e86f352e44"></a><!-- doxytag: member="cppdb::result::operator=" ref="a5acf6cc3f8d01a57b62ec5e86f352e44" args="(result const &amp;)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdb_1_1result.html">result</a> const&amp; cppdb::result::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classcppdb_1_1result.html">result</a> const &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Assign result, note it only keeps the reference to actual object so assignment is just copy of the reference </p>

</div>
</div>
<a class="anchor" id="abd97afe7f35bc9cab506b5dbef2fcec5"></a><!-- doxytag: member="cppdb::result::operator&gt;&gt;" ref="abd97afe7f35bc9cab506b5dbef2fcec5" args="(tags::into_tag&lt; T &gt; ref)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdb_1_1result.html">result</a>&amp; cppdb::result::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">tags::into_tag&lt; T &gt;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Syntactic sugar, used together with <a class="el" href="namespacecppdb.html#a882d26dfb19b5feb499a2fe680622ace" title="Create a pair of value and tag for fetching a value from row.">into()</a> function.</p>
<p>res &lt;&lt; into(x,y) is same as</p>
<div class="fragment"><pre class="fragment"> y = res.<a class="code" href="classcppdb_1_1result.html#a5666960dab2f5101b5bf06495a948bc4">fetch</a>(x) ? <a class="code" href="namespacecppdb.html#a3aab3f09990a102e787c2d6927b842a5a204e4484496653859e2d8e4389ee816d" title="The valus is not a null value.">not_null_value</a> : <a class="code" href="namespacecppdb.html#a3aab3f09990a102e787c2d6927b842a5a11728bd6190aba68f210c8cf20c5313e" title="The value is null value.">null_value</a> 
</pre></div> 
</div>
</div>
<a class="anchor" id="ac7cc80653e1fb917542a02aa47aa5e0a"></a><!-- doxytag: member="cppdb::result::operator&gt;&gt;" ref="ac7cc80653e1fb917542a02aa47aa5e0a" args="(T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classcppdb_1_1result.html">result</a>&amp; cppdb::result::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Syntactic sugar, same as fetch(<em>value</em>) </p>

</div>
</div>
<a class="anchor" id="ad80bad15460333ceb63b04a7892d2901"></a><!-- doxytag: member="cppdb::result::rewind_column" ref="ad80bad15460333ceb63b04a7892d2901" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classcppdb_1_1result.html#ad80bad15460333ceb63b04a7892d2901">cppdb::result::rewind_column</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Reset current column index, so fetch without column index can be used once again </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>cppdb/<a class="el" href="frontend_8h_source.html">frontend.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sat Jun 23 2012 12:37:00 for CppDB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
